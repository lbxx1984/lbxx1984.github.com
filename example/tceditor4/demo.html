<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>TcEditor v4</title>
<script language="javascript" src="include/raphael-2.1.1.min.js"></script>
<script language="javascript" src="include/jquery-1.9.1.min.js"></script>
<script language="javascript" src="include/three-63.min.js"></script>
<script language="javascript" src="include/three-stats.min.js"></script>
<script language="javascript" src="include/three-Detector.js"></script>

<script language="javascript" src="draw.js"></script>
<link href="css/main.css" type="text/css" rel="stylesheet" charset="utf-8"/>

</head>
<body>
<div id="container" style="position:absolute;left:0px;top:0px;height:800px;width:900px;"></div>
<div id="display" style="position:absolute;left:950px;top:0px;height:800px;width:900px;background-color:#333;"></div>
<script>

			if ( ! Detector.webgl ){
				Detector.addGetWebGLMessage();
			} else {
				
				var container, stats, object,point,pointx,pointy,pointz;
				var camera, scene, renderer;
				init();
				var display=showPoints(object);
				animate();
			}
			
			function showPoints(obj) {
                
				var width=900;
				var height=800;			
				var r = Raphael("display", width, height);
				var discattr = {fill: "#fff", stroke:"#f00"};
	
				//与控制点对应的平面点队列
				var points=[];
				var faces=[];
				
				//添加点
				for(var n=0;n<obj.geometry.vertices.length;n++){
					var pos=RectangularToDisplay(obj.geometry.vertices[n].x,obj.geometry.vertices[n].y);
					var point=r.circle(pos[0],pos[1],3).attr(discattr);
					points.push(point);
				}				
				//添加边
				
				for(var n=0;n<obj.geometry.faces.length;n++){
					var face3d=obj.geometry.faces[n];
					var face={};
					face.a=points[face3d.a];
					face.b=points[face3d.b];
					face.c=points[face3d.c];
					face.path = [
						["M",face.a.attr("cx"),face.a.attr("cy")],
						["L",face.b.attr("cx"),face.b.attr("cy")],
						["L",face.c.attr("cx"),face.c.attr("cy")],
						["L",face.a.attr("cx"),face.a.attr("cy")]
					];
					face.curve=r.path(face.path).attr({stroke:Raphael.getColor(), "stroke-width":0.2});
					faces.push(face);	
				}
				
				//坐标映射函数
				function RectangularToDisplay(x,y){
					x=x+width*0.5;
					y=height*0.5-y;
					return [x,y];
				}
				//坐标旋转
				function axisRotate(x,y,z,matrix){
					var rx=matrix[0][0]*x+matrix[0][1]*y+matrix[0][2]*z;
					var ry=matrix[1][0]*x+matrix[1][1]*y+matrix[1][2]*z;
					var rz=matrix[2][0]*x+matrix[2][1]*y+matrix[2][2]*z;
					return [rx,ry,rz];
				}
	
				return {
					update:function(object){
						var matrix=getMatrix(object);
						for(var n=0;n<obj.geometry.vertices.length;n++){
							var posRotated=axisRotate(obj.geometry.vertices[n].x,obj.geometry.vertices[n].y,obj.geometry.vertices[n].z,matrix);
							var pos=RectangularToDisplay(posRotated[0],posRotated[1]);
							points[n].attr({cx:pos[0],cy:pos[1]});
						}
						for(var n=0;n<faces.length;n++){
							faces[n].path[0][1]=faces[n].a.attr("cx");
							faces[n].path[0][2]=faces[n].a.attr("cy");
							faces[n].path[1][1]=faces[n].b.attr("cx");
							faces[n].path[1][2]=faces[n].b.attr("cy");
							faces[n].path[2][1]=faces[n].c.attr("cx");
							faces[n].path[2][2]=faces[n].c.attr("cy");
							faces[n].path[3][1]=faces[n].a.attr("cx");
							faces[n].path[3][2]=faces[n].a.attr("cy");
							faces[n].curve.attr({path:faces[n].path});
						}
						// path[1][1] = X;
                        //path[1][2] = Y;
                        //path2[1][1] = X;
                        //path2[1][2] = Y;
                       // curve.attr({path: path});

					}	
				}
 			};						
			
			function getMatrix(obj){
				
				//初始单位向量
				var x={x:1,y:0,z:0};
				var y={x:0,y:1,z:0};
				var z={x:0,y:0,z:1};
				
				//y轴z轴绕x轴旋转
				y=rotating(y,x,obj.rotation.x);
				z=rotating(z,x,obj.rotation.x);	
				//x轴z轴绕y轴旋转
				x=rotating(x,y,obj.rotation.y);
				z=rotating(z,y,obj.rotation.y);
				//x轴y轴绕z轴旋转
				x=rotating(x,z,obj.rotation.z);
				y=rotating(y,z,obj.rotation.z);
				
				//旋转
				function rotating(p,a,theta){
					
					//p为目标点, a为旋转轴, theta为旋转角度, WebGL使用右手坐标系, 传入的theta要取反, 然后计算方向余弦和角度正弦余弦, 提高计算速度
					theta=-theta;	
					var d=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
					var nx=-a.x/d;
					var ny=-a.y/d;
					var nz=-a.z/d;
					var cos=Math.cos(theta);
					var sin=Math.sin(theta);
					var fcos=1-cos;
					
					//坐标变化
					var x=	p.x* ( nx*nx*fcos+	cos	  )+ p.y* ( nx*ny*fcos-nz*sin )+ p.z* ( nx*nz*fcos+ny*sin );
					var y=	p.x* ( nx*ny*fcos+ nz*sin )+ p.y* ( ny*ny*fcos+	  cos )+ p.z* ( ny*nz*fcos-nx*sin );		
					var z=  p.x* ( nx*nz*fcos- ny*sin )+ p.y* ( ny*nz*fcos+nx*sin )+ p.z* ( nz*nz*fcos+	  cos );
					
					return {x:x,y:y,z:z}
				}
				
				return  [
					[x.x,y.x,z.x],
					[x.y,y.y,z.y],
					[x.z,y.z,z.z]
				];
				
			}
		
			function init() {

				container = $("#container")[0];
				camera = new THREE.PerspectiveCamera( 20, 1000 / 800, 1, 2000 );
				camera.position.y = 0;
				camera.position.z = 500;
				camera.position.x = 0;
				
				scene = new THREE.Scene();
				scene.add( new THREE.AmbientLight( 0xffffff ) );

				var map = THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;

				var material = new THREE.MeshBasicMaterial( { color: 0xffaa00, wireframe: true } );
					
				object = new THREE.Mesh( new THREE.SphereGeometry( 75, 20, 10 ), material );
				object.position.set( 0, 0, 0 );
				scene.add( object );

				var axis = new THREE.AxisHelper( 200 );
				axis.position.set( 0,0,0 );
				scene.add( axis );
					
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( 1000, 800);
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

			}


			//

			function animate() {
				requestAnimationFrame( animate );
				
				//object.rotation.x+=Math.PI*0.002;
				//object.rotation.y+=Math.PI*0.002;
				//object.rotation.z+=Math.PI*0.002;
				
				//display.update(object);

				camera.lookAt( scene.position );
				renderer.render( scene, camera );
				stats.update();
			}

		</script>

</body>
</html>
